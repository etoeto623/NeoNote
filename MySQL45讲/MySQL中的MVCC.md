>MVCC是InnoDB提供的用来进行事务隔离的实现

# MVCC
在InnoDB中，一条记录会有多个版本，存在多条记录，如下：
![[mysql-mvcc记录图解.excalidraw]]
其中，三个虚线箭头就是undo log，V1、V2、V3不是真实存在的，而是根据undo log计算出来的
# read view
在隔离级别为*读提交*和*可重复读*的隔离级别下，开启一个事务时，会**给事务分配一个事务id，为单调自增的**，同时还有一个***read view***
``` text
在实现上，InnoDB为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。“活跃”指的就是，启动了但还没提交。
```
read view的结构如下：
![[mysql-readview结构.excalidraw]]
对于一条记录，有几种情况：
- 事务id小于低水位，表示是一提交的事务，可见
- 事务id大于高水位，表示该数据是在本事务之后生成的，不可见
- 在高低水位之间，视情况
	- 在未提交事务合集中，表示是还未提交的数据，不可见
	- 不在未提交事务合集中，表示是已提交的数据，可见
``` info
一条记录的历史版本可能并不是保持事务id的顺序，比如，记录的历史版本可能是：txid(1)->txid(3)->txid(2)
```

read view的规则简化：
1. 版本未提交，不可见
2. 版本已提交，但是是在视图创建后提交的，不可见
3. 版本已提交，而且是在视图创建前提交的，可见

# 快照读和当前读
根据MVCC的规则读取数据是快照读，select语句就是快照读
读取当前数据的最新版为当前读，update语句会隐式的当前读。**select语句如果加锁，也是当前读**
# 读提交和可重复读
读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
- 在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图
- 在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图

#mvcc